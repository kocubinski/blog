#+POSTID: 31
#+DATE: [2013-05-03 Fri 16:39]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil TeX:nil
#+CATEGORY: c#
#+TAGS:
#+DESCRIPTION:
#+TITLE: Generating C# Enums from database with T4 Templates

A pattern I've seen more than a few times in a relational database is to use a table as an
"enum".  Suppose for instance we have a table which contains a list of configuration keys
and their default values, we'll call it *ConfigurationKeys*.

| KeyId | KeyName             | DefaultValue  |
|-------+---------------------+---------------|
|     4 | SiteBackgroundColor | BlindingWhite |

Now we want to look up or set a value of this key, for that our table looks like

| Id | KeyId | SiteId | Value           |
|----+-------+--------+-----------------|
|  2 |     4 |      1 | Dinosaur Purple |

So, for Site Id 1, the background color is set to gray. Its probably not a great idea to
store a site's background color (?) as table row, but we're going to do it anyway because we're just
that wacky. To lookup or set this value from code, we're stuck looking up a string,
"SiteBackgroundColor" from the database, which sucks. What I really want is an enum
generated from the *ConfigurationKeys* table which I can use in my queries. This is
actually very easy to do with a T4 Text Template.

#+BEGIN_SRC t4
<#@ include file="ConfigProvider.ttinclude" #>
/* This code was generated by ConfigurationKeys.tt, do not edit! */
// ReSharper disable InconsistentNaming
namespace Kocubinski
{
    public enum ConfigurationKeys
    {
        <# 
        var keys = GetKeys();
        int count = 0;
        var comma = new Func<int, string>(i => i == 0 ? " " : ",");
        foreach (ConfigKey key in keys)
        {
            var keyName = key.KeyName.Replace("-", "_");
        #>
<#= comma(count) #><#= keyName #> = <#= key.KeyId #>
        <# 
            count++;
        }
        #>

    }
}
// ReSharper enable InconsistentNaming
 
<#+  
    class ConfigKey
    {
        public int KeyId { get; set; }
        public string KeyName { get; set; }
        public string DefaultValue { get; set; }
    }


    IList<ConfigKey> GetKeys()
    {
        string connectString = GetConnectionString();

        var conn = new SqlConnection(connectString);
        var cmd = new SqlCommand("SELECT KeyId, KeyName, DefaultValue FROM dbo.DimcConfigurationKeys", conn);
        conn.Open();
        var reader = cmd.ExecuteReader();
        var res = new List<ConfigKey>();
        while (reader.Read())
        {
            var record = (IDataRecord)reader;
            res.Add(new ConfigKey {
                KeyId = int.Parse(record[0].ToString()),
                KeyName = record[1].ToString(),
                DefaultValue = record[2].ToString()
            });
        }

        return res;
    }
#+END_SRC

This results in something like:

#+BEGIN_SRC csharp
  public enum ConfigurationKeys
  {
    SiteBackgroundColor = 4
    ,NumberOfFooWidgets = 5
  }
#+END_SRC


Yea.  Well we lost our LINQ to SQL because I haven't figured out how to use the ORM from a
design-time compiled T4 template, but its pretty simple query so no big deal.  You'll also
noticed I've abstracted out the logic to find the database connection to separate,
re-usable .ttinclude file.

This is a very basic use of a t4 template, but you can imagine where we can go from here.
What if instead our *ConfigurationKeys* table looked like this

| KeyId | KeyName             | DefaultValue  | Type          |
|-------+---------------------+---------------+---------------|
|     4 | SiteBackgroundColor | BlindingWhite | System.String |
|     5 | NumberOfFooWidgets  | 4             | System.Int32  |

Now instead of generated an enum, how about a class with strongly typed properties? We can
write the Type column as a C# literal for something like this:

#+BEGIN_SRC t4
  public class SiteConfiguration
  {
      private readonly int _siteId;
  
      public SiteConfiguration(int siteId)
      {
          _siteId = siteId;
      }
  
      string GetConfigValue(int keyId)
      {
          // Code to return the key value from the database or null if no entry for given siteId.
      }
  
      foreach (ConfigKey key in keys)
      {
          var keyName = key.KeyName.Replace("-", "_");
      #>
  
          public <#= key.Type #> <#= keyName #> 
          { 
              get 
              {
                  return GetConfigValue(<#= key.KeyId #>) ?? "<#= key.DefaultValue #>";
              }
          }
      <# 
      }
      #>
  
      }
  }
  
#+END_SRC

That's pretty cool.  One of my favorite lanauage features of Lisp are macros, generating
code and code-as-data.  Well this captures some of that essence.  I'm really liking T4
templates so far, and get the feeling I'm only scratching the surface.

How else will I abuse them? Generating ASPX? Storing and mutating C# classes in the
database to mutate at design time?

** Gists
You can find gists for [[https://gist.github.com/kocubinski/5513554][DbEnum.tt T4 template]] and the [[https://gist.github.com/kocubinski/5513575][ConfigProvider.tt T4 template]].
